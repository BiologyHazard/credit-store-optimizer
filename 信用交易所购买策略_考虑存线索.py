import math
import multiprocessing
import random
from abc import ABC, abstractmethod
from typing import Sequence

import numpy as np

from 信用交易所模型 import 信用交易所, 信用交易所商品
from 统计结果 import 信用交易所统计结果


class 信用交易所购买策略(ABC):
    @abstractmethod
    def 快速求解(self, 商店序号: int, 当前信用: int, 当前线索: float) -> tuple[int, float, int, int]:
        pass


class 最优购买策略的近似策略(信用交易所购买策略):
    def __init__(self,
                 每日获得的信用: int,
                 每日获得的线索折算信用: int):
        from 中间结果.信用能购买的商品碎片的价值 import 信用能购买的商品碎片的价值
        x, y = np.ogrid[:301, :221]
        index_array = 每日获得的信用 + 每日获得的线索折算信用 - 260 + x + y
        self.L_N减1_D_·_· = 信用能购买的商品碎片的价值(index_array)

    def 快速求解(self, 商店序号: int, 当前信用: int, 当前线索折算信用: int) -> tuple[int, float, int, int]:
        from 中间结果.价格价值矩阵 import 价值矩阵, 价格矩阵

        价值行 = 价值矩阵[商店序号]
        价格行 = 价格矩阵[商店序号]
        目标函数最大值 = -math.inf
        for 总价格, 总价值 in zip(价格行, 价值行):
            if 总价格 <= 当前信用 + 当前线索折算信用 // 20 * 20:
                剩余信用 = 当前信用 - 总价格
                剩余线索折算信用 = 当前线索折算信用
                if 剩余信用 < 0:
                    传递线索数量 = math.ceil(-剩余信用 / 20)
                    剩余信用 += 传递线索数量 * 20
                    剩余线索折算信用 -= 传递线索数量 * 20
                能够继承的信用 = min(剩余信用, 300)
                目标函数 = 总价值 + self.L_N减1_D_·_·[能够继承的信用, 剩余线索折算信用]
                if 目标函数 > 目标函数最大值:
                    目标函数最大值 = 目标函数
                    最优策略总价格 = 总价格
                    最优策略总价值 = 总价值
                    最优策略能够继承的信用 = 能够继承的信用
                    最优策略能够继承的线索折算信用 = 剩余线索折算信用
        return 最优策略总价格, 最优策略总价值, 最优策略能够继承的信用, 最优策略能够继承的线索折算信用


class 按性价比从高到低购买_并设定性价比阈值策略(信用交易所购买策略):
    def __init__(self, 阈值: float | None = None, 每日获得的信用: int | None = None):
        if 阈值 is not None:
            self.阈值 = 阈值
        else:
            from 中间结果.K··· import K_N减1_·_·
            if 每日获得的信用 is None:
                raise TypeError('必须提供阈值或者每日获得的信用')
            self.阈值 = (K_N减1_·_·(每日获得的信用, 300) - K_N减1_·_·(每日获得的信用, 0)) / 300

    @staticmethod
    def 计算当前折算价格(当前信用: int, 商品: 信用交易所商品) -> float:
        return max(min(300 - (当前信用 - 商品.现价), 商品.现价), 0)

    @staticmethod
    def 计算当前折算性价比(当前信用: int, 商品: 信用交易所商品) -> float:
        当前折算价格 = 按性价比从高到低购买_并设定性价比阈值策略.计算当前折算价格(当前信用, 商品)
        return 商品.价值 / 当前折算价格 if 当前折算价格 > 0 else math.inf

    def 快速求解(self, 商店序号: int, 当前信用: int, 当前线索折算信用: int) -> tuple[int, float, int, int]:
        商店 = 信用交易所统计结果[商店序号]
        总价格 = 0
        总价值 = 0
        for 商品 in sorted(商店.商品列表, key=lambda x: x.性价比, reverse=True):
            if 商品.现价 <= 当前信用 + 当前线索折算信用 // 20 * 20 and self.计算当前折算性价比(当前信用, 商品) >= self.阈值:
                总价格 += 商品.现价
                总价值 += 商品.价值
                当前信用 -= 商品.现价
                if 当前信用 < 0:
                    传递线索数量 = math.ceil(-当前信用 / 20)
                    当前信用 += 传递线索数量 * 20
                    当前线索折算信用 -= 传递线索数量 * 20
            else:
                break
        能够继承的信用 = min(当前信用, 300)
        return 总价格, 总价值, 能够继承的信用, 当前线索折算信用


def 模拟一轮购买(
    策略: 信用交易所购买策略,
    每日获得的信用: int,
    每日获得的线索折算信用: int,
    初始继承信用: int,
    初始继承线索折算信用: int,
    顺序: list[int],
) -> float:
    当前信用 = 初始继承信用 + 每日获得的信用
    当前线索折算信用 = 初始继承线索折算信用 + 每日获得的线索折算信用
    已购买总价值 = 0
    for 商店序号 in 顺序:
        # 先传递溢出的线索
        if 当前线索折算信用 > 220:
            传递的线索数量 = math.ceil((当前线索折算信用 - 220) / 20)
            当前信用 += 传递的线索数量 * 20
            当前线索折算信用 -= 传递的线索数量 * 20
        # 快速求解
        总价格, 总价值, 剩余信用, 剩余线索折算信用 = 策略.快速求解(商店序号, 当前信用, 当前线索折算信用)
        已购买总价值 += 总价值
        当前信用 = 剩余信用 + 每日获得的信用
        当前线索折算信用 = 剩余线索折算信用 + 每日获得的线索折算信用
    return 已购买总价值 / len(顺序)


def 比较策略的优劣(
    策略字典: dict[str, 信用交易所购买策略],
    每日获得的信用: int,
    每日获得的线索折算信用: int,
    初始继承信用: int,
    初始继承线索折算信用: int,
    顺序: list[int],
) -> dict[str, float]:
    return {
        策略名称: 模拟一轮购买(策略, 每日获得的信用, 每日获得的线索折算信用, 初始继承信用, 初始继承线索折算信用, 顺序)
        for 策略名称, 策略 in 策略字典.items()
    }


def 策略字典(每日获得的信用: int, 每日获得的线索折算信用: int):
    return {
        '最优购买策略的近似策略': 最优购买策略的近似策略(每日获得的信用=每日获得的信用, 每日获得的线索折算信用=每日获得的线索折算信用),
        '按性价比从高到低购买，并设定性价比阈值策略': 按性价比从高到低购买_并设定性价比阈值策略(每日获得的信用=每日获得的信用 + 每日获得的线索折算信用),
    }


if __name__ == '__main__':
    每日获得的信用列表 = [813 - 76]  # range(500, 901, 50)
    每日获得的线索折算信用 = 76
    初始继承信用 = 0
    初始继承线索折算信用 = 0

    random.seed(0)
    顺序 = list(range(len(信用交易所统计结果))) * 5
    random.shuffle(顺序)

    with multiprocessing.Pool() as pool:
        结果 = pool.starmap(
            比较策略的优劣,
            ((策略字典(每日获得的信用, 每日获得的线索折算信用),
              每日获得的信用, 每日获得的线索折算信用, 初始继承信用, 初始继承线索折算信用, 顺序)
             for 每日获得的信用 in 每日获得的信用列表),
        )

    不同购买策略的比较 = {
        策略名称: {
            str(每日获得的信用): 结果[i][策略名称]
            for i, 每日获得的信用 in enumerate(每日获得的信用列表)
        }
        for 策略名称 in next(iter(结果))
    }
    print(不同购买策略的比较)
